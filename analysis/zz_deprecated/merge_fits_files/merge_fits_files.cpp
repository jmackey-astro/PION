/// \file merge_fits_files.cpp
/// \author Jonathan Mackey
///
/// This file reads in fits files generated by parallel code and stitches the
/// partial files together into a single file.
/// input files are of name filename_procno.timestep.fits
///
/// 2016.06.15 JM: updated for new PION version.

#ifndef PARALLEL
#error "define PARALLEL so this will work!"
#endif


#include "defines/functionality_flags.h"
#include "defines/testing_flags.h"

#include "constants.h"
#include "sim_params.h"
#include "tools/mem_manage.h"

#include "tools/timer.h"

#include "dataIO/dataio_fits.h"
#include "grid/setup_fixed_grid_MPI.h"
#include "grid/uniform_grid.h"
#include "sub_domain/sub_domain.h"

#include "fitsio.h"
#include <sstream>
using namespace std;

int main(int argc, char **argv)
{
  int err = 0;
  // Get an input file, an output file, and a step.
  if (argc != 5) {
    cerr << "Error: must call as follows...\n";
    cerr
        << "merge_fits_files <source_path> <infilebase> <outfile> <nproc>\n";  // <startstep> <step>\n";
    exit(1);
  }
  string input_path  = argv[1];
  string infilebase  = argv[2];
  string outfilebase = argv[3];

  //
  // Also initialise the sub_domain class with myrank and nproc.
  // Get nproc from command-line (number of fits files for each
  // snapshot)
  //
  class SimParams SimPM;

  class Sub_domain *sub_domain = &(SimPM.levels[0].sub_domain);

  int nproc = atoi(argv[4]);

  int myrank = sub_domain->get_myrank();
  sub_domain->set_nproc(nproc);

  cout << "reading from file base " << infilebase << endl;
  cout << "Writing to file " << outfilebase << endl;
  // cout <<"Step between outputs is "<<step<<" timesteps.\n";
  cout << "number of processors: " << sub_domain->get_nproc() << "\n";
  cout << "**********************************************\n";
  // Open two input files and output file.
  class DataIOFits dataio(SimPM);
  class file_status fs;

  fitsfile *ffin, *ffout;
  int status = 0;
  ostringstream temp;
  string infile, outfile;

  //*******************************************************************
  // Get input files
  //*******************************************************************
  cout << "-------------------------------------------------------\n";
  cout << "--------------- Getting List of Files to read ---------\n";
  //
  // Get list of files to read:
  //
  list<string> files;
  string infile_zero = infilebase + "_0000";
  err += dataio.get_files_in_dir(input_path, infile_zero, &files);
  if (err) spdlog::error("{}: {}", "failed to get list of files", err);
  //
  // Remove non-FITS files from list
  //
  for (list<string>::iterator s = files.begin(); s != files.end(); s++) {
    // If file is not a .fits file, then remove it from the list.
    if ((*s).find(".fits") == string::npos) {
      cout << "removing file " << *s << " from list.\n";
      files.erase(s);
      s = files.begin();
    }
    else {
      cout << "files: " << *s << endl;
    }
  }
  for (list<string>::iterator s = files.begin(); s != files.end(); s++) {
    cout << "files: " << *s << endl;
  }
  size_t nfiles = files.size();
  size_t ifile  = 0;
  if (nfiles < 1)
    spdlog::error("{}: {}", "Need at least one file, but got none", nfiles);

  cout << "--------------- Got list of Files ---------------------\n";
  cout << "-------------------------------------------------------\n";
  //
  // Set up an iterator to run through all the files.
  //
  list<string>::iterator ff = files.begin();
  cout << "-------------------------------------------------------\n";
  cout << "--------------- Starting Loop over all input files ----\n";
  cout << "-------------------------------------------------------\n";
  clk.start_timer("analyse_data");

  //*******************************************************************
  // loop over all files:
  //*******************************************************************

  for (ifile = 0; ifile < nfiles; ifile++) {
    cout.flush();
    cout << "------ Starting Next Loop: ifile=" << ifile << ", time so far=";
    cout << clk.time_so_far("analyse_data") << " ----\n";

    temp.str("");
    temp << input_path << "/" << *ff;
    string infile = temp.str();
    ff++;

    cout << "\n*****************************************************\n";
    cout << "Opening fits file " << infile << "\n";
    err = fits_open_file(&ffin, infile.c_str(), READONLY, &status);
    if (status) {
      fits_report_error(stderr, status);
      return (err);
    }

    //
    // This should set LocalXmin and Xmin/max/range/NG
    //
    sub_domain->set_myrank(0);
    err = dataio.ReadHeader(infile, SimPM);
    if (err) spdlog::error("{}: {}", "Didn't read header", err);
    sub_domain->decomposeDomain(SimPM.ndim, SimPM.levels[0]);

    //
    // Outfile:
    //
    temp.str("");
    temp << outfilebase << ".";
    temp.width(8);
    temp.fill('0');
    temp << SimPM.timestep << ".fits";
    outfile = temp.str();

    if (dataio.file_exists(outfile)) {
      temp.str("");
      temp << "!" << outfile;
      outfile = temp.str();
      cout << "Output file exists!  hopefully this is ok.\n";
    }
    fits_create_file(&ffout, outfile.c_str(), &status);
    if (status) {
      cerr << "outfile open went bad.\n";
      exit(1);
    }


    cout << "infile[0]: " << infile << "\nand outfile: " << outfile << endl;

    //
    //  - copy header from first infile.
    //
    err = fits_copy_header(ffin, ffout, &status);
    if (status) {
      fits_report_error(stderr, status);
      return (err);
    }

    //
    //  - for each hdu in proc 0 infile, create full size image hdu in outfile
    //
    int num;
    err = fits_get_num_hdus(ffin, &num, &status);
    if (status) {
      fits_report_error(stderr, status);
      return (err);
    }
    long int *pix = new long int[SimPM.ndim];
    for (int j = 0; j < SimPM.ndim; j++)
      pix[j] = SimPM.NG[j];
    cout << "\tCreating " << num << " hdus in outfile (including header)...";
    rep.printVec("pix", pix, 2);

    for (int i = 2; i <= num; i++) {  // hdu1 is header.
      fits_create_img(ffout, DOUBLE_IMG, SimPM.ndim, pix, &status);
      // get hdu name from ffin
      ffmahd(ffin, i, 0, &status);
      if (status) {
        cout << "move to infile hdu " << i << endl;
        fits_report_error(stderr, status);
        return (err);
      }
      char keyval[32];
      fits_read_keyword(ffin, "extname", keyval, 0, &status);
      string sss = keyval;
      // cout <<"sss="<<sss;
      int length = sss.length();
      sss        = sss.substr(1, length - 2);
      // cout <<" sss="<<sss<<endl;
      strcpy(keyval, sss.c_str());
      fits_write_key(ffout, TSTRING, "extname", keyval, "Image Name", &status);
      if (status) {
        cout << "reading/writing extname for hdu " << i << endl;
        fits_report_error(stderr, status);
        return (err);
      }
    }
    cout << " done.\n";
    delete[] pix;
    err += fits_close_file(ffin, &status);
    if (status) {
      fits_report_error(stderr, status);
      return (err);
    }

    //
    // - for each hdu in proc i infile, copy image into appropriate
    // place in oufile image.
    //
    cout << "\tNow copying infile hdus into outfile.\n";
    for (int proc = 0; proc < sub_domain->get_nproc(); proc++) {
      cout << "\t\tproc " << proc << ": ";
      sub_domain->set_myrank(proc);
      sub_domain->decomposeDomain(SimPM.ndim, SimPM.levels[0]);
      //
      // read infile header to get local ng/xmin/xmax
      //
      // temp.str("");temp<<infilebase<<"_"<<proc<<"."<<start<<".fits";
      // infile = temp.str();
      temp.str("");
      temp << input_path << "/" << infilebase << "_";
      temp.width(4);
      temp.fill('0');
      temp << proc;
      infile = dataio.choose_filename(temp.str(), SimPM.timestep);
      // temp.str(""); temp <<outfilebase<<"."<<start<<".fits";
      if (!fs.file_exists(infile))
        spdlog::error("{}: {}", "infile doesn't exist", infile);

      err = dataio.ReadHeader(infile, SimPM);
      if (err) spdlog::error("{}: {}", "Didn't read header", err);
      sub_domain->set_myrank(proc);
      sub_domain->decomposeDomain(SimPM.ndim, SimPM.levels[0]);

      err = fits_open_file(&ffin, infile.c_str(), READONLY, &status);
      if (status) {
        fits_report_error(stderr, status);
        return (err);
      }

      double *array = 0;
      cout << "sub_domain->LocalNcell = " << sub_domain->LocalNcell << "\n";
      array = new double[sub_domain->LocalNcell];
      if (!array) spdlog::error("{}: {}", "mem alloc", array);

      for (int im = 2; im <= num; im++) {  // hdu1 is header.
        ffmahd(ffin, im, 0, &status);
        ffmahd(ffout, im, 0, &status);
        if (status) {
          cout << "move to infile/outfile hdu " << im << endl;
          fits_report_error(stderr, status);
          return (err);
        }
        cout << " hdu" << im;
        //
        // read image from infile into array.
        //
        long int *fpix = new long int[SimPM.ndim];
        long int *lpix = new long int[SimPM.ndim];
        long int *inc =
            new long int[SimPM.ndim];  // I think this is the increment in num.
                                       // pix. per read.
        long int npix = 1;
        double dx     = sub_domain->LocalRange[XX] / sub_domain->LocalNG[XX];
        for (int i = 0; i < SimPM.ndim; i++) {
          inc[i]  = 1;
          fpix[i] = 1;
          lpix[i] =
              sub_domain->LocalNG[i];  // It's inclusive: fpix,fpix+1,...,lpix
          npix *= (lpix[i] - fpix[i] + 1);  // +1 because of previous line.
          //    cout <<"fpix[i],lpix[i] = "<<fpix[i]<<", "<<lpix[i]<<endl;
        }
        if (npix != sub_domain->LocalNcell) {
          cout << "ncell = " << sub_domain->LocalNcell << " and counted "
               << npix << " cells.\n";
          spdlog::error(
              "{}: {}", "Pixel counting failed in Image Read",
              npix - sub_domain->LocalNcell);
        }
        double nulval = -1.e99;
        int anynul    = 0;
        // Read data from image.
        fits_read_subset(
            ffin, TDOUBLE, fpix, lpix, inc, &nulval, array, &anynul, &status);
        if (status) {
          fits_report_error(stderr, status);
          return status;
        }

        //
        // write image into subset of output file.
        //
        npix = 1;
        for (int i = 0; i < SimPM.ndim; i++) {
          fpix[i] =
              static_cast<long int>(
                  (sub_domain->LocalXmin[i] - SimPM.Xmin[i]) / dx * 1.00000001)
              + 1;
          lpix[i] = fpix[i] + sub_domain->LocalNG[i]
                    - 1;  // -1 because it's inclusive: fpix,pfix+1,...,lpix
          npix *= (lpix[i] - fpix[i] + 1);  // +1 because of previous line.
                                            //	   cout <<"fpix[i],lpix[i] =
                                            //"<<fpix[i]<<", "<<lpix[i]<<endl;
        }
        if (npix != sub_domain->LocalNcell) {
          cout << "ncell = " << sub_domain->LocalNcell << " and counted "
               << npix << " cells.\n";
          spdlog::error(
              "{}: {}", "Pixel counting failed in Image Write",
              npix - sub_domain->LocalNcell);
        }
        fits_write_subset(ffout, TDOUBLE, fpix, lpix, array, &status);
        if (status) fits_report_error(stderr, status);
        delete[] fpix;
        fpix = 0;
        delete[] lpix;
        lpix = 0;
        delete[] inc;
        inc = 0;
      }  // copy all images. (int im)
      cout << "\n";

      err += fits_close_file(ffin, &status);
      if (status) {
        fits_report_error(stderr, status);
        return (err);
      }
      delete[] array;
      array = 0;
    }  // loop over all infiles (int proc)
    cout << "\tOutfile " << outfile << " written.  Moving to next step.\n";
    //  - close outfile.
    err += fits_close_file(ffout, &status);
    if (status) {
      fits_report_error(stderr, status);
      return (err);
    }

  }  // loop over all timesteps.
  cout << "\n***************************************************\n";
  // cout <<"couldn't find file "<<infile<<" for step "<<start<<"... assuming
  // i'm finished!\n";

  return 0;
}
