/// \file map-2d-to-3d.cpp
/// \author Jonathan Mackey
///
/// This file reads in silo files generated by 2d axisymmetric runs and
/// maps them onto a 3D grid with the same physical domain.
///
/// Mods:

#ifndef PARALLEL
#error "define PARALLEL so this will work!"
#endif

#include <cmath>

#include <fstream>
#include <iostream>
#include <list>
#include <silo.h>
#include <sstream>
using namespace std;

#include "defines/functionality_flags.h"
#include "defines/testing_flags.h"

#include "constants.h"

#ifdef SPDLOG_FWD
#include <spdlog/fwd.h>
#endif
#include <spdlog/spdlog.h>
/* prevent clang-format reordering */
#include <fmt/ranges.h>
#include <spdlog/sinks/rotating_file_sink.h>

#include "dataIO/dataio_base.h"
#include "dataIO/dataio_silo.h"
#include "dataIO/dataio_silo_utility.h"
#include "grid/uniform_grid.h"
#include "sim_params.h"
#include "sub_domain/sub_domain.h"

#ifndef PION_NESTED
#error "Only works for nested grid"
#endif

#ifndef PARALLEL
#error "Only works for MPI parallel code"
#endif

#include "grid/setup_grid_NG_MPI.h"
#include "sim_control/sim_control_NG_MPI.h"

#ifdef PION_OMP
#include <omp.h>
#endif


// ##################################################################
// ##################################################################


int get_2d_pos(
    const std::array<double, MAX_DIM> &pos3d,  ///< input 3D coords
    std::array<double, MAX_DIM> &pos2d,        ///< output 2d coords
    int &lev2d,                           ///< output level on 2D grid for pos2d
    vector<class GridBaseClass *> &grid,  ///< input 2d grids
    class SimParams &SimPM                ///< input 2d parameters
)
{
  // cylindrical coordinates [z,R], map to 3D coords (x,y,z)
  pos2d[Zcyl] = pos3d[ZZ];
  pos2d[Tcyl] = 0.0;
  pos2d[Rcyl] = sqrt(pos3d[XX] * pos3d[XX] + pos3d[YY] * pos3d[YY]);
  // spdlog::info("2d pos: {}",pos2d);

  // find which grid it is on
  for (int l = SimPM.grid_nlevels - 1; l >= 0; l--) {
    bool onlev = true;
    if (pos2d[Zcyl] < SimPM.levels[l].Xmin[Zcyl]
        || pos2d[Zcyl] > SimPM.levels[l].Xmax[Zcyl])
      onlev = false;
    if (pos2d[Rcyl] < SimPM.levels[l].Xmin[Rcyl]
        || pos2d[Rcyl] > SimPM.levels[l].Xmax[Rcyl])
      onlev = false;
    if (onlev) {
      lev2d = l;
      break;
    }
  }

  return 0;
}


// ##################################################################
// ##################################################################



int get_2d_data(
    const std::array<double, MAX_DIM> &pos2d,  ///< input position we want
    const int l,                          ///< input level of leaf cell at pos2d
    vector<class GridBaseClass *> &grid,  ///< input 2D grids
    class SimParams &par,                 ///< input 2D grid parameters
    const std::array<double, MAX_DIM> &maxpos,  ///< input max size of grid
    std::vector<double> &data  ///< output: state vector from 2D cell.
)
{
  // find cell on 2D grid level l
  std::array<double, MAX_DIM> ipos;
  CI.get_ipos_as_double(pos2d, ipos);
  int del = CI.get_integer_cell_size() / 2;
  for (int lev = par.grid_nlevels - 1; lev > l; lev--)
    del *= 2;
  cell *c = grid[l]->FirstPt();
  // spdlog::info("moving in z: {}      {}",c->pos, ipos);
  do {
    if (c->pos[Zcyl] + del > ipos[Zcyl]) break;
    // spdlog::info("moving in z: {}",c->pos);
    c = grid[l]->NextPt(*c, ZPcyl);
  } while (c != 0);
  do {
    // if we are at the point we look for, then break.
    if (c->pos[Rcyl] + del > ipos[Rcyl]) break;
    // check if we are off end of coarsest grid in R and take that value
    if (c->pos[Rcyl] + del == maxpos[Rcyl]) {
      // spdlog::info("found cell: l = {}, c->pos {},   ipos {}",l,c->pos,
      // ipos);
      break;
    }
    c = grid[l]->NextPt(*c, RPcyl);
  } while (c != 0);
  if (!c) {
    spdlog::error("got lost on 2D grid: l = {}, pos = {}", l, ipos);
    spdlog::error("Xmin {}", par.levels[l].Xmin);
    spdlog::error("Xmax {}", par.levels[l].Xmax);
    exit(1);
  }
  // else {
  // spdlog::info("found cell: l = {}, c->pos {},   ipos {}",l,c->pos, ipos);
  // CI.print_cell(*c);
  //}

  for (int v = 0; v < par.nvar; v++) {
    data[v] = c->P[v];
  }
  return 0;
}


// ##################################################################
// ##################################################################


int main(int argc, char **argv)
{
  int err = 0;

  // auto max_logfile_size = 1048576 * 5;
  // auto max_logfiles     = 3;
  // spdlog::set_default_logger(spdlog::rotating_logger_mt(
  //    "silocompare", "silocompare.log", max_logfile_size, max_logfiles));

#ifdef NDEBUG
  spdlog::set_level(spdlog::level::info);
  spdlog::flush_on(spdlog::level::err);
#else
  spdlog::set_level(spdlog::level::trace);
  spdlog::flush_on(spdlog::level::trace);
#endif

  // ----------------------------------------------------------------
  // Get an input file and an output file.
  if (argc < 3) {
    spdlog::error(
        "Error: must call as follows...\nmap-2d-to-3d <2d-level00-file> <3d-parameter-file> [omp-nthreads=N]");
    spdlog::error("{}: {}", "Bad number of args", argc);
    exit(1);
  }
  string file2d = argv[1];
  string pfile  = argv[2];
  spdlog::info("input file: {}, 3d paramter file: {} ", file2d, pfile);
  std::vector<string> args(argc);
  for (int i = 0; i < argc; ++i)
    args[i] = argv[i];
    // ----------------------------------------------------------------


    // ----------------------------------------------------------------
#ifdef PION_OMP
  // set number of OpenMP threads, if included
  int nth        = 100;  // set to large number initially
  bool found_omp = false;
  for (int i = 0; i < argc; i++) {
    if (args[i].find("omp-nthreads=") != string::npos) {
      nth = atoi((args[i].substr(13)).c_str());
      if (nth > omp_get_num_procs()) {
        spdlog::warn("override: requested too many threads");
        nth = min(nth, omp_get_num_procs());
      }
      spdlog::warn("override: setting OpenMP N-threads to {}", nth);
      found_omp = true;
    }
  }
  if (found_omp)
    omp_set_num_threads(nth);
  else
    omp_set_num_threads(1);
#endif /* PION_OMP */
  // ----------------------------------------------------------------


  // ----------------------------------------------------------------
  // set up vector of grids for 2D snapshot and read in data.
  class SimParams SimPM2d;
  int r  = SimPM2d.levels[0].sub_domain.get_myrank();
  int np = SimPM2d.levels[0].sub_domain.get_nproc();
  if (np > 1) {
    spdlog::error("only works with one MPI process: {}", np);
    exit(np);
  }
  spdlog::info("map-2d-to-3d: myrank={}, nproc={}", r, np);
  SimPM2d.typeofip = 5;
  SimPM2d.levels[0].sub_domain.set_ReadSingleFile(true);
  // set up dataio_utility class
  string dtype = "DOUBLE";
  class dataio_silo_utility dataio2d(
      SimPM2d, dtype, &(SimPM2d.levels[0].sub_domain));
  // read header
  err = dataio2d.ReadHeader(file2d, SimPM2d);
  if (0 != err) {
    spdlog::error("PLLEL Init(): failed to read header: {}", err);
    exit(err);
  }
  // setup grid
  vector<class GridBaseClass *> grid2d(SimPM2d.grid_nlevels);
  class setup_grid_NG_MPI *SimSetup2d = new setup_grid_NG_MPI();
  SimSetup2d->setup_NG_grid_levels(SimPM2d);
  err        = SimSetup2d->setup_grid(grid2d, SimPM2d);
  SimPM2d.dx = grid2d[0]->DX();
  if (!grid2d[0]) {
    spdlog::error("Grid setup failed: {}", fmt::ptr(grid2d[0]));
    exit(1);
  }
  // Now assign data to the grid from file
  err = dataio2d.ReadData(file2d, grid2d, SimPM2d);
  if (0 != err) {
    spdlog::error("(INIT::assign_initial_data) err = {}", err);
    exit(err);
  }
  spdlog::info("finished reading 2D data to grid 1");
  // ----------------------------------------------------------------

  // ----------------------------------------------------------------
  // Set up the 3D grid based on parameter file
  // first read in parameters to SimPM struct.
  class SimParams SimPM(pfile);
  r  = SimPM.levels[0].sub_domain.get_myrank();
  np = SimPM.levels[0].sub_domain.get_nproc();
  if (np > 1) {
    spdlog::error("3D only works with one MPI process: {}", np);
    exit(np);
  }
  spdlog::info("map-2d-to-3d: myrank={}, nproc={}", r, np);


  // sim-setup function
  class setup_grid_NG_MPI *SimSetup = new setup_grid_NG_MPI();
  SimSetup->setup_NG_grid_levels(SimPM);

  // Set up a grid(s).
  vector<class GridBaseClass *> grid(SimPM.grid_nlevels);
  err      = SimSetup->setup_grid(grid, SimPM);
  SimPM.dx = grid[0]->DX();
  if (!grid[0]) {
    spdlog::error("{}: {}", "Grid setup failed", fmt::ptr(grid[0]));
    exit(1);
  }
  spdlog::info("set up 3D grid");

  // setup parameters class
  class ReadParams *rp = new ReadParams;
  if (!rp) {
    spdlog::error("icgen:: initialising RP {}", fmt::ptr(rp));
    exit(1);
  }
  err += rp->read_paramfile(pfile);
  if (err) {
    spdlog::error("Error reading parameterfile {}", pfile);
    exit(1);
  }

  // setup spatial solver
  err = SimSetup->set_equations(SimPM);
  if (0 != err) {
    spdlog::error("(icgen::set_equations) err!=0 {}", err);
    exit(1);
  }
  class FV_solver_base *solver = SimSetup->get_solver_ptr();

  // setup microphysics module
  spdlog::info("setting up microphysics module");
  class microphysics_base *MP = 0;
  SimSetup->setup_microphysics(SimPM);
  MP = SimSetup->get_mp_ptr();
  solver->SetMicrophysics(MP);

  // now grids should exist and parameters struct should have 3D data
  // ----------------------------------------------------------------


  // ----------------------------------------------------------------
  // Loop through 3D Grids and assign data based on interpolation of
  // 2D data.
  // * need function to get 2D position for 3D position
  // * need function to get 2D cell data for this position
  // * assign 3D data based on 2D data (zeroth order interpolation?)

  CI.set_ndim(SimPM2d.ndim);
  double dx = (SimPM2d.Xmax[XX] - SimPM2d.Xmin[XX]) / SimPM2d.NG[XX];
  CI.set_nlevels(dx, SimPM2d.grid_nlevels);
  CI.set_nvar(SimPM2d.nvar);
  CI.set_xmin(SimPM2d.Xmin);
  std::array<double, MAX_DIM> maxpos;
  CI.get_ipos_as_double(SimPM2d.levels[0].Xmax, maxpos);
  spdlog::info("maxpos on 2d grid: {}", maxpos);

  for (int l = 0; l < SimPM.grid_nlevels; l++) {
    spdlog::info("interpolating 2d data onto 3D grid: level {}", l);
    cell *c = grid[l]->FirstPt();
    std::array<double, MAX_DIM> pos3d, pos2d;
    std::vector<double> data(SimPM2d.nvar);
    int lev2d = 0;
    do {
      // set cell-interface for 3D
      CI.set_ndim(SimPM.ndim);
      dx = (SimPM.Xmax[XX] - SimPM.Xmin[XX]) / SimPM.NG[XX];
      CI.set_nlevels(dx, SimPM.grid_nlevels);
      CI.set_nvar(SimPM.nvar);
      CI.set_xmin(SimPM.Xmin);
      CI.get_dpos(*c, pos3d);
      // spdlog::info("cell pos: {}",pos3d);
      err += get_2d_pos(pos3d, pos2d, lev2d, grid2d, SimPM2d);

      // now set cell-interface to 2D grid to find cell:
      CI.set_ndim(SimPM2d.ndim);
      dx = (SimPM2d.Xmax[XX] - SimPM2d.Xmin[XX]) / SimPM2d.NG[XX];
      CI.set_nlevels(dx, SimPM2d.grid_nlevels);
      CI.set_nvar(SimPM2d.nvar);
      CI.set_xmin(SimPM2d.Xmin);
      err += get_2d_data(pos2d, lev2d, grid2d, SimPM2d, maxpos, data);

      // finally set 3d cell data to 2d value.
      for (int v = 0; v < SimPM2d.nvar; v++) {
        c->P[v]  = data[v];
        c->Ph[v] = data[v];
      }
      // have to rotate vectors correctly.
      double theta = atan2(pos3d[YY], pos3d[XX]);
      double ct = cos(theta), st = sin(theta);
      // spdlog::info("pos: {},   theta = {}", c->pos, theta);

      c->P[VZ] = data[VX];  // x-dir in 2d is Z, in 3D map to Z
      c->P[VX] = data[VY] * ct - data[VZ] * st;
      c->P[VY] = data[VY] * st + data[VZ] * ct;
      c->P[BZ] = data[BX];  // x-dir in 2d is Z, in 3D is X
      c->P[BX] = data[BY] * ct - data[BZ] * st;
      c->P[BY] = data[BY] * st + data[BZ] * ct;
    } while ((c = grid[l]->NextPt(*c)) != 0);
  }
  spdlog::info("finished interpolation");
  // ----------------------------------------------------------------


  // ----------------------------------------------------------------
  // save data and quit
  class dataio_silo_utility dataio(
      SimPM, "DOUBLE", &SimPM.levels[0].sub_domain);
  err = dataio.OutputData(SimPM.outFileBase, grid, SimPM, 0);
  if (err) {
    spdlog::error("File write error {}", err);
    exit(err);
  }
  spdlog::info("finished writing data");
  for (auto &g : grid)
    delete g;
  for (auto &g : grid2d)
    delete g;
  // ----------------------------------------------------------------

  return err;
}
