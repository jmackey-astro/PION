/// \file silo2text.cpp
/// \author Jonathan Mackey
///
/// This file reads in silo files generated by serial and parallel code
/// and re-writes the data as a single text file.
///
/// Mods:
/// - 2011.12.14 JM: converted from silocompare.cc
/// - 2013.09.05 JM: Fixed for pion; added microphysics so ascii
///    files can have gas temperature written out.
/// - 2013.10.04 JM: Added output frequency to skip silo files.
/// - 2014.06.07 JM: Added mpv8 -- heating/cooling microphysics class
/// - 2016.03.03 JM: renamed to silo2text.cpp and tried to get it working.

#ifndef PARALLEL
#error "define PARALLEL so this will work!"
#endif

#include "defines/functionality_flags.h"
#include "defines/testing_flags.h"

#include "constants.h"
#include "sim_params.h"
#include "tools/mem_manage.h"

#include "tools/timer.h"

#include "grid/setup_fixed_grid_MPI.h"
#include "grid/uniform_grid.h"
#include "sub_domain/sub_domain.h"

#include <dirent.h>
#include <errno.h>

#include <list>
#include <sstream>
using namespace std;
#include "dataIO/dataio_base.h"
#include "dataIO/dataio_silo.h"
#include "dataIO/dataio_silo_utility.h"
#include "dataIO/dataio_text.h"
#include <silo.h>

#include "microphysics/microphysics_base.h"

#ifdef SPDLOG_FWD
#include <spdlog/fwd.h>
#endif
#include <spdlog/sinks/rotating_file_sink.h>
#include <spdlog/spdlog.h>
/* prevent clang-format reordering */

#ifdef CODE_EXT_HHE
#include "future/mpv9_HHe.h"
#endif

int main(int argc, char **argv)
{
  int err = 0;

  auto max_logfile_size = 1048576 * 5;
  auto max_logfiles     = 3;
#ifdef PARALLEL
  spdlog::set_default_logger(spdlog::rotating_logger_mt(
      "silo2text_pre_mpi", "silo2text.log", max_logfile_size, max_logfiles));
#else
  spdlog::set_default_logger(spdlog::rotating_logger_mt(
      "silo2text", "silo2text.log", max_logfile_size, max_logfiles));
#endif /* PARALLEL */

#ifdef NDEBUG
  spdlog::set_level(spdlog::level::info);
  spdlog::flush_on(spdlog::level::err);
#else
  spdlog::set_level(spdlog::level::trace);
  spdlog::flush_on(spdlog::level::trace);
#endif

  //
  // Also initialise the sub_domain class with myrank and nproc.
  //
  //
  // get a setup_grid class, to set up the grid, and a grid pointer.
  //
  class setup_fixed_grid *SimSetup = 0;
  SimSetup                         = new setup_fixed_grid_pllel();
  class SimParams SimPM;

  int myrank = SimPM.levels[0].sub_domain.get_myrank();
  int nproc  = SimPM.levels[0].sub_domain.get_nproc();

#ifdef PARALLEL
  spdlog::set_default_logger(spdlog::rotating_logger_mt(
      "silo2text", "silo2text_process" + to_string(myrank) + ".log",
      max_logfile_size, max_logfiles));
#endif /* PARALLEL */

  spdlog::info("Projection3D: myrank={}, nproc={}", myrank, nproc);

  //
  // Get an input file and an output file.
  //
  if (argc != 5) {
    spdlog::error(
        "Error: must call as follows...\nsilo2text: <silo2text> <source-dir> <file-base>  <output-file> <op-freq>\n  op-freq: if this is e.g. 10, we only convert every 10th input file to a text file");
    spdlog::error("{}: {}", "Bad number of args", argc);
  }
  string fdir        = argv[1];
  string firstfile   = argv[2];
  string outfilebase = argv[3];
  string outfile;
  size_t op_freq = atoi(argv[4]);

  //
  // set up dataio_utility class
  //
  class dataio_silo_utility dataio(
      SimPM, "DOUBLE", &(SimPM.levels[0].sub_domain));
  //
  // Get list of first and second files to read, and make sure they match.
  //
  list<string> files;
  err += dataio.get_files_in_dir(fdir, firstfile, &files);
  if (err) spdlog::error("{}: {}", "failed to get list of files", err);
  //
  // Remove non-SILO files from list
  //
  for (list<string>::iterator s = files.begin(); s != files.end(); s++) {
    // If file is not a .silo file, then remove it from the list.
    if ((*s).find(".silo") == string::npos) {
      spdlog::debug("removing file {} from list", *s);
      files.erase(s);
      s = files.begin();
    }
    else {
      spdlog::debug("files: {}", *s);
    }
  }
  //
  // Set up iterators to run through all the files.
  //
  list<string>::iterator ff = files.begin();
  unsigned int nfiles       = files.size();
  vector<class GridBaseClass *> G;
  class GridBaseClass *grid = 0;

  //
  // loop over all files: open first and write a text file.
  //
  for (unsigned int fff = 0; fff < nfiles; fff += op_freq) {
    ostringstream oo;
    oo.str("");
    oo << fdir << "/" << *ff;
    firstfile = oo.str();

    class file_status fstat;
    if (!fstat.file_exists(firstfile)) {
      spdlog::debug("first file: {}", firstfile);
      spdlog::error("{}: {}", "First file doesn't exist", firstfile);
    }

    //
    // Read in first code header so i know how to setup grid.
    //
    err = dataio.ReadHeader(firstfile, SimPM);
    if (err) spdlog::error("{}: {}", "Didn't read header", err);
    SimPM.grid_nlevels     = 1;
    SimPM.levels[0].parent = 0;
    SimPM.levels[0].child  = 0;
    SimPM.levels[0].Ncell  = SimPM.Ncell;
    for (int v = 0; v < MAX_DIM; v++)
      SimPM.levels[0].NG[v] = SimPM.NG[v];
    for (int v = 0; v < MAX_DIM; v++)
      SimPM.levels[0].Range[v] = SimPM.Range[v];
    for (int v = 0; v < MAX_DIM; v++)
      SimPM.levels[0].Xmin[v] = SimPM.Xmin[v];
    for (int v = 0; v < MAX_DIM; v++)
      SimPM.levels[0].Xmax[v] = SimPM.Xmax[v];
    SimPM.levels[0].dx         = SimPM.Range[XX] / SimPM.NG[XX];
    SimPM.levels[0].simtime    = SimPM.simtime;
    SimPM.levels[0].dt         = 0.0;
    SimPM.levels[0].multiplier = 1;
    err                        = SimPM.levels[0].sub_domain.decomposeDomain(
        SimPM.ndim, SimPM.levels[0], SimPM.get_pbc_bools());
    if (err) spdlog::error("{}: {}", "main: failed to decompose domain!", err);

    // *****************************************************
    //
    // Setup microphysics and grid
    //
    if (fff == 0) {
      //
      // Now setup microphysics and raytracing classes
      //
      err += SimSetup->setup_microphysics(SimPM);
      // err += SimSetup->setup_raytracing(SimPM);
      err += SimSetup->set_equations(SimPM);
      if (err)
        spdlog::error("{}: {}", "Setup of microphysics and raytracing", err);

      //
      // May need to setup extra data in each cell for ray-tracing optical
      // depths and/or viscosity variables (here just set it to zero).
      //
      CI.setup_extra_data(SimPM.RS, 0, 0, 0);
      //
      // Setup grid.
      //
      G.resize(1);
      SimSetup->setup_grid(G, SimPM);
      grid = G[0];
      if (!grid) spdlog::error("{}: {}", "Grid setup failed", fmt::ptr(grid));
      spdlog::debug("\t\tg={}\tDX = {}", fmt::ptr(grid), grid->DX());
    }  // first step, setup grid and microphysics.
    // *****************************************************


    //
    // Set output file name.
    //
    oo.str("");
    oo << outfilebase << ".";
    oo.fill('0');
    oo.width(8);
    oo << SimPM.timestep << ".txt";
    outfile = oo.str();
    spdlog::info(
        "\n**************************************************************************************\nfff={}\tinput file: {}\toutput file: {}",
        fff, firstfile, outfile);

    //
    // Read data (this reader can read serial or parallel data.
    //
    err = dataio.ReadData(firstfile, G, SimPM);
    if (0 != err)
      spdlog::error(
          "{}: Expected {} but got {}", "(main) Failed to read data", 0, err);
    // ***************************************************************
    // ********* FINISHED FIRST FILE, MOVE ON TO OUTPUT FILE *********
    // ***************************************************************

    class dataio_text textio(SimPM);
    err += textio.OutputData(outfilebase, G, SimPM, SimPM.timestep);
    if (err) {
      spdlog::error("\t Error writing data");
      return (1);
    }

    //
    // move onto next first and second files
    //
    for (size_t vv = 0; vv < op_freq; vv++)
      ff++;
  }  // move onto next file

  return 0;
}
